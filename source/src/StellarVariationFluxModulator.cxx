/*
 * StellarVariationFluxModulator.cxx
 *
 *  Created on: 22 Feb 2016
 *      Author: futyand
 */

#include <fstream>
#include <stdlib.h>

#include "StellarVariationFluxModulator.hxx"

void StellarVariationFluxModulator::initialize(const ModuleParams& params) {

	m_rotationPeriod = params.GetAsDouble("rotationPeriod");
	m_seed = params.GetAsInt("stellarVariationSeed");

}

void StellarVariationFluxModulator::doBegin(Data* data, bool fullFrame) {

	if (data->getFieldOfView()->getStars().size() == 0) {
		throw runtime_error("Error in StellarVariationFluxModulator::doBegin: No stars in FOV. Check that the pointing direction corresponds to the target star coordinates.");
	}
	Star::spectralType spectralType = data->getFieldOfView()->getStars()[m_starIndex]->getSpectralType();
	double duration = data->getTimeConfiguration().getDuration();
	//double days = duration/(24.*3600.);
	//if (days < 1./(24.*6.)) days = 1./(24.*6.);
	double duration_minutes = duration/60.;

	//Generate the stellar variation with time
	string command = "python3 " + string(getenv("CHEOPS_SW")) + "/resources/spotter.py -t " + to_string(max(duration_minutes,10.)) +
					 " -c 10 --force --seed "+to_string(m_seed)+" " + to_string(m_rotationPeriod) + " "+Star::spectralTypeString[spectralType];
	cout << command.c_str() << endl;
	int success = system(command.c_str());
	if (success!=0) throw runtime_error("Error in StellarVariationFluxModulator::doBegin: call to spotter.py has failed");

	//Read the time series from the temporary file generated by spotter.py
	ifstream variation_in("lc0000"+to_string(m_starIndex)+"_00001", ios::in);
	if (!variation_in.good()) throw runtime_error("Error in StellarVariationFluxModulator::doBegin opening stellar flux variation file");
	int i=0;
	string dummy;
	double timeFromFile,variationFromFile;
	while(variation_in.good()) {
		variation_in >> timeFromFile >> variationFromFile;
		if(variation_in.eof()) break;
		m_time.push_back(timeFromFile*60.);
		m_variation.push_back(variationFromFile);
		cout << "stellar variation flux factor at time " << m_time[i] << "s = " << m_variation[i] << endl;
		i++;
	}
	variation_in.close();

	//Remove the temporary file from disk
	command = "rm lc0000"+to_string(m_starIndex)+"_00001";
	success = system(command.c_str());

}

void StellarVariationFluxModulator::process(Data* data, int timeStep, bool fullFrame) const {

	double currentTime = data->getTimeConfiguration().getTimeSinceStart(timeStep);

	//Identify the first row in the stellar variation file for which the time is later than the current time
	int ifile = 1;
	for (unsigned i=1; i<m_time.size(); i++) {
		if (m_time[i] >= currentTime) {
			ifile = i;
			break;
		}
	}

	//Perform a linear interpolation between the flux factor values in the rows on either side of the current time
	double timeFrac = (currentTime- m_time[ifile-1])/(m_time[ifile]-m_time[ifile-1]);
	double fluxFactor = (1.-timeFrac)*m_variation[ifile-1] + timeFrac*m_variation[ifile];
	//cout << ifile << " " << currentTime << " " << m_time[ifile-1] << " " << m_time[ifile] << " "
	//	 << m_variation[ifile-1] << " " << m_variation[ifile] << " " << timeFrac << " " << fluxFactor << endl;

	data->getFieldOfView()->getStars()[m_starIndex]->getTimeSeries()[timeStep]->setVariationFluxFactor(fluxFactor);

}
