/*
 * WavelengthDependence.hxx
 *
 *  Created on: 4 Feb 2016
 *      Author: futyand
 */

#ifndef DATA_INCLUDE_WAVELENGTHDEPENDENCE_HXX_
#define DATA_INCLUDE_WAVELENGTHDEPENDENCE_HXX_

#include <string>

#include "data/include/Star.hxx"

using namespace std;

/** *************************************************************************
 *  @author David Futyan UGE
 *
 *  @brief This class is used to generate weights as a function of wavelength
 *  	   to be applied to monochromatic PSFs and empirical flat fields.
 *  	   It also generates stellar spectra and provides the wavelength
 *  	   integrated global throughput.
 *
 *  Weights are generated by calling the generateWeights method, and can
 *  be later retrieved for a given wavelength using the getWeight method.
 *  The class also provides access to the QE and throughput distributions,
 *  as well as the wavelength integrated throughput and throughput*QE
 *  weighted according to the spectrum of the target star (either black
 *  body or SED according to whether or not a valid REF_APP_SEDTeff file
 *  is provided).
 */

class WavelengthDependence {
public:

	static constexpr double kPlanck = 6.6260693e-27; ///< Planck constant, for energy in ergs
	static constexpr double kBoltzmann = 1.380658e-16; ///< Boltzmann constant, for energy in ergs
	static constexpr double kSpeedOfLight = 299792458.0; ///< Speed of light

	static const int kNWavelength = 1541; ///< Number of wavelength bins (corresponds to 0.5nm steps from 330 to 1100nm)
	static const int kNTEff = 50; ///< Number of effective temperature bins in the REF_APP_SEDTeff reference file

	/// @brief Bandpass used to define stellar flux normalization
	enum REFERENCE_BAND{Vband,GaiaBand};

	/// @brief V-band transmission curve, as defined in Buser & Kurucz (1978)
	static const double VbandTransmission(int index) {
		static const double transmission_Vband[54] = {0,0.03,0.084,0.163,0.301,0.458,0.630,0.780,0.895,
		            0.967,0.997,1.,0.988,0.958,0.919,0.877,0.819,0.765,
		            0.711,0.657,0.602,0.545,0.488,0.434,0.386,0.331,0.289,
		            0.25,0.214,0.181,0.151,0.12,0.093,0.069,0.051,0.036,
		            0.027,0.021,0.018,0.016,0.014,0.012,0.011,0.010,0.009,
		            0.008,0.007,0.006,0.005,0.004,0.003,0.002,0.001,0.};
	  return transmission_Vband[index];
	}

	/** *************************************************************************
	 *  @brief Constructor. Initializes the object by calling readThroughput,
	 *  	   readQuantumEfficiency and readSEDs to generate arrays for throughput
	 *  	   and QE and stellar flux in 0.5nm steps
	 *
	 *  @param [in] applyThroughput  Flag to indicate whether or not to apply
	 *  							 optical throughput
	 *  @param [in] throughputFilename  filename for the optical throughput file
	 *  @param [in] applyQE  Flag to indicate whether or not to apply
	 *  					 quantum efficiency
	 *  @param [in] QEFilename  filename for the quantum efficiency file
	 *  @param [in] SEDFilename  filename for the REF_APP_SEDTeff file
	 *  @param [in] targetSEDFilename  filename for the optional user provided file
	 *  							   to define the target SED
	 */
	WavelengthDependence(bool applyThroughput, string throughputFilename,
			 	 	 	 bool applyQE, string QEFilename, string SEDFilename, string targetSEDFilename);

	virtual ~WavelengthDependence() {};

	/** *************************************************************************
	 *  @brief Returns the flux of Planck black body with the specified effective
	 *  	   temperature, at the specified wavelength.
	 *  	   Planck spectrum normalized to 1.
	 *
	 *  @param [in] wavelength  Wavelength in angstroms
	 *  @param [in] effectiveTemperature  Black body effective temperature
	 */
	static double planckRadiance(double wavelength, double effectiveTemperature);

	/** *************************************************************************
	 *  @brief Calls generatePhotonSpectrum to generate the stellar spectrum
	 *  	   corresponding to the specified effective temperature in 0.5nm
	 *  	   steps. Generates a weight for each 0.5nm wavelength bin as the
	 *  	   product of spectrum*throughput*QE. The distribution of weights
	 *  	   is normalized to 1.
	 *
	 *  @param [in] effectiveTemperature  Effective temperature of the target
	 *  								  star used to generate the stellar
	 *  								  spectrum. Use 0 for Vega spectrum,
	 *  								  -1 for flat spectrum.
	 */
	void generateWeights(double effectiveTemperature);

	/** *************************************************************************
	 *  @brief Returns the wavelength integrated transmission in the
	 *  	   reference passband (Gaia passband or V-band),
	 *  	   weighted according to the spectrum of the target star: Calls
	 *  	   generatePhotonSpectrum to generate the stellar spectrum
	 *  	   corresponding to the specified effective temperature in 0.5nm
	 *  	   steps and calculates the integral of spectrum*transmission.
	 *
	 *  @param [in] refBand 			  Reference passband: GaiaBand or Vband
	 *  @param [in] effectiveTemperature  Effective temperature of the target
	 *  								  star used to generate the stellar
	 *  								  spectrum. Use 0 for Vega spectrum,
	 *  								  -1 for flat spectrum.
	 *  @param [in] target				  Flag to indicate whether or not the
	 *  								  Star is the target
	 */
	double getIntegratedRefBandTransmission(REFERENCE_BAND refBand, double effectiveTemperature, bool target=false) const;

	/** *************************************************************************
	 *  @brief Returns the wavelength integrated throughput*QE, weighted
	 *  	   according to the spectrum of the target star: Calls
	 *  	   generatePhotonSpectrum to generate the stellar spectrum
	 *  	   corresponding to the specified effective temperature in 0.5nm
	 *  	   steps and calculates the integral of spectrum*throughput*QE.
	 *
	 *  @param [in] effectiveTemperature  Effective temperature of the target
	 *  								  star used to generate the stellar
	 *  								  spectrum. Use 0 for Vega spectrum,
	 *  								  -1 for flat spectrum.
	 *  @param [in] ccdTemperature  Temperature of the CCD (affects QE)
	 *  @param [in] target				  Flag to indicate whether or not the
	 *  								  Star is the target
	 */
	double getIntegratedThroughputQE(double effectiveTemperature, double ccdTemperature, bool target=false) const;

	/** *************************************************************************
	 *  @brief Returns the wavelength integrated throughput, weighted
	 *  	   according to the spectrum of the target star: Calls
	 *  	   generatePhotonSpectrum to generate the stellar spectrum
	 *  	   corresponding to the specified effective temperature in 0.5nm
	 *  	   steps and calculates the integral of spectrum*throughput.
	 *
	 *  @param [in] effectiveTemperature  Effective temperature of the target
	 *  								  star used to generate the stellar
	 *  								  spectrum. Use 0 for Vega spectrum,
	 *  								  -1 for flat spectrum.
	 */
	double getIntegratedThroughput(double effectiveTemperature) const;

	/// @brief Returns the weight corresponding to the specified wavelength range,
	///		   as a sum over the weights (calculated by generateWeights) within that range
	double getWeight(double wavelengthLow, double wavelengthHigh) const;

	/// @ brief Returns the quantum efficiency at the specified wavelength
	double getQE(double wavelength) const {return m_qe[getBin(wavelength)];}

	/// @ brief Returns the throughput at the specified wavelength
	double getThroughput(double wavelength) const {return m_throughput[getBin(wavelength)];}

	/// @brief Returns a boolean to indicate whether or not QE is applied
	bool applyQE() const {return m_applyQE;}

	/// @brief Returns a boolean to indicate whether or not throughput is applied
	bool applyThroughput() const {return m_applyThroughput;}

	/// @brief Returns the name of the QE filename (used later to set a header keyword for the truth flat field)
	string getQEFilename() const {return m_QEFilename;}

	/// @brief Returns the name of the throughput filename (used later to set a header keyword for the truth flat field)
	string getThroughputFilename() const {return m_throughputFilename;}

    /** *************************************************************************
     *  @brief Generates the stellar energy spectrum corresponding to the specified
     *  	   effective temperature, with 1nm resolution as used by StarProducer,
     *  	   normalizing it to 1
     *
     *  @param [inout] stellarEnergySpectrum	Energy spectrum array with values in
     *  										Star::kNWavelength*10 wavelength bins
     *  @param [in] effectiveTemperature		Effective temperature of the star.
	 *  								  		Use 0 for Vega spectrum, -1 for flat spectrum.
	 *  @param [in] target						Flag to indicate whether or not the
	 *  										Star is the target
     */
	void getStellarEnergySpectrum_1nm(double (&stellarEnergySpectrum)[Star::kNWavelength*10], double effectiveTemperature, bool target) const;

	/// @brief Sets the photon flux spectrum for Vega
	void setVegaFluxSpectrum(double flux_Vega[kNWavelength]);

private:

	/// @brief Reads in the throughput vs wavelength from the input file and performs a linear interpolation to 0.5nm steps
	void readThroughput();

	/// @brief Generates the V band transmission vs wavelength in 0.5nm steps
	void generateVbandTransmission();

	/// @brief Generates the Gaia band transmission vs wavelength in 0.5nm steps
	void generateGaiaBandTransmission();

	/// @brief Generates the flux of Vega vs wavelength in 0.5nm steps
	void generateVegaSpectrum();

	/// @brief Reads in the QE vs wavelength from the input file and performs a linear interpolation to 0.5nm steps
	void readQuantumEfficiency();

	/// @brief Reads in the SEDs from the input REF_APP_SEDTeff file and performs a linear interpolation to 0.5nm steps
	void readSEDs();

	/// @brief Reads in the user provided SED file and performs a linear interpolation to 0.5nm steps
	void readUserSED();

    /** *************************************************************************
     *  @brief Generates a stellar spectrum (black body or SED according to
     *  	   whether or not a valid REF_APP_SEDTeff file has been provided)
     *  	   corresponding to the specified effective temperature, normalizing it to 1
     *
     *  @param [inout] photon_spectrum	flux array with values in kNWavelength wavelength bins
     *  @param [in] effectiveTemperature	Effective temperature of the star.
	 *  								  	Use 0 for Vega spectrum, -1 for flat spectrum.
	 *  @param [in] target				Flag to indicate whether or not the Star is the target
     */
	void generatePhotonSpectrum(double (&photon_spectrum)[kNWavelength], double effectiveTemperature, bool target=false) const;

    /** *************************************************************************
     *  @brief Uses linear interpolation to transform an array of values sampling
     *         a function of variable x to a new array with different x sampling
     *
     *  @param [in] x_ref  Input x array (e.g. wavelength with binning of input file)
     *  @param [in] y_ref  Input y array (e.g. throughput with binning of input file)
     *  @param [in] size_ref  Number of bins for input arrays
     *  @param [in] x  Output x array (e.g. wavelength with output binning)
     *  @param [in] y  Output y array (e.g. throughput with output binning)
     *  @param [in] size  Number of bins for output arrays
     */
	void linearInterpolation(const double (&x_ref)[2000], const double (&y_ref)[2000], unsigned size_ref, double * x, double * y, unsigned size) const;

	/// @brief Returns the bin of the data member arrays (storted in 0.5nm steps) corresponding to the specified wavelength
	int getBin(double wavelength) const;

	bool m_applyThroughput; ///< Flag to indicate whether or not to apply throughput
	string m_throughputFilename; ///< NAme of the input file for throughput vs wavelength

	bool m_applyQE; ///< Flag to indicate whether or not to apply QE
	string m_QEFilename; ///< Name of the input file for QE vs wavelength

	string m_SEDFilename; ///< Name of the REF_APP_SEDTeff input file
	string m_targetSEDFilename; ///< Name of the optional user provided file to define the target SED

	bool m_blackBody; ///<Flag to indicate whether to use black body rather than SEDs
	bool m_VegaSpectrum; ///<Flag to indicate whether to use Vega spectrum

	double m_wavelength[kNWavelength]; ///< Array containing wavelength values from 330nm to 1100nm in 0.5nm steps
	double m_throughput[kNWavelength]; ///< Array storing the throughput for each of the wavelength values in m_wavelength
	double m_transmission_Vband[kNWavelength]; ///< Array storing the V band transmission for each of the wavelength values in m_wavelength
	double m_transmission_GaiaBand[kNWavelength]; ///< Array storing the Gaia band transmission for each of the wavelength values in m_wavelength
	double m_qe[kNWavelength]; ///< Array storing the quantum efficiency for each of the wavelength values in m_wavelength
	double m_qeVsTempSlope[kNWavelength]; ///< Array storing the slope of the QE vs temperature for each of the wavelength values in m_wavelength
	double m_SEDFlux[kNWavelength][kNTEff]; ///< Array storing the flux values read from the REF_APP_SEDTeff input for each of the wavelength values in m_wavelength, for each effective temperature
	double m_targetSEDFlux[kNWavelength]; ///< Array storing the flux values read from the optional user provided target SED file for each of the wavelength values in m_wavelength
	double m_SEDTeff[kNTEff]; ///< Array storing the set of effective temperature values in the REF_APP_SEDTeff input
	double m_weight[kNWavelength]; ///< Array storing the global throughput weights for each of the wavelength values in m_wavelength
	double m_flux_Vega[kNWavelength]; ///< Array storing the flux from Vega for each of the wavelength values in m_wavelength

};

#endif /* DATA_INCLUDE_WAVELENGTHDEPENDENCE_HXX_ */
